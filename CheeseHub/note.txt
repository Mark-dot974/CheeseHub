th:text=""  和th:utext=""的区别。
utext会将转义字符转义（如&lt;转义为<）

注册
注册功能分为两步：一步是用户输入信息都正确的话，将信息存到数据库中，此时用户的状态为注册成功未激活（0），并且向用户发送一封激活邮件。然后返回中转页面。
              另一步是激活账户。点击链接后会请求对应的controller方法（携带参数，userId，激活码）来激活账户。

登录功能会给每个user发放一个cookie，作为凭证，登录时的记住我若是被勾选上了，则延长cookie的存在时间（expiredSeconds），让用户在一段时间内不需要重复登录。

退出时，根据cookie（”ticket”）值将对应用户的登录状态改变即可。

显示用户信息时，为什么不直接吧用户信息存到session中？而使用cookie存放一个ticket来找到用户信息？
因为用户信息敏感，如此更安全

显示用户信息
使用**拦截器**实现，在每个controller方法之前，根据ticket判断用户是否登录，若是登录了，则将用户信息存放到ThreadLocal中（使用ThreadLocal是为了保证线程安全
，因为一个服务器可能同时响应多个客户端的请求），ThreadLocal相当于一个保证线程安全的全局容器（也就相当于session），在本次请求的任何过程中都可以从中获得数据。
在postHandler方法中如果用户登录了，则将用户信息从ThreadLocal中取出，放到model中，有前端进行用户信息展示。

修改用户信息
1. 修改用户头像，为了后面部署到服务器，头像等文件的路径应该动态的存到配置文件中。且每个用户的头像存放的路径为访问服务器的url，显示头像时，多加一个controller方法
这样更安全。
2. 修改用户密码。比较输入的密码是否相同，然后更新密码即可。要注意的是存的密码都加了salt。

自定义注解
有些功能如设置用户个人信息应该需要登录后才能访问，故应该使用拦截器对其进行拦截。而应该拦截那些方法，为了便捷，使用自定义注解标记。

敏感词过滤(可以改进，因为每次next佩佩失败后，又回到了开头位置，)
1. 先将定义的敏感词（存放在文件中，每个敏感词为一行）构造成**前缀树**，每个敏感词是树中的从根到叶节点的一条路径。
问：为什么使用前缀树而不使用KMP？
因为同一个文本要匹配多个敏感词，使用前缀树效率更高（前缀相同的敏感词不用重复匹配，不然使用KMP有多少个敏感词就要匹配多少次）
而且使用KMP会根据next数组，跳过一些字符开头，若是只是匹配一个字符串，这没问题。
可是这里需要匹配多个字符串，跳过的这些字符串开头有可能也是敏感词，所以不能使用KMP。

2. 使用特定字符将敏感词过滤替换。
过程：使用3个指针，cur指向前缀树（初始：根节点），begin指向待过滤的文本（初始：开头），next指向待过滤的文本（初始：开头）

比较cur（根节点）是否有begin指向的字符的subNode，
如果没有，说明当前字符开头的不可能是敏感词，begin和next同时往后移动。不过滤此字符
如果有，说明当前字符开头的可能是敏感词，则begin不动，next往后移动 , cur移动到对应的subNode。
比较cur是否有以next指向的字符的subNode，如果有，则next移动，cur移动。
如果cur移动到的字符是叶节点，说明begin~next之间的字符是敏感词，将其用指定字符替换。
如果中途cur！=next，则begin往后移动一位，next=begin.

发布帖子
前端：在index.js中向后端发送ajax请求。

后端：收到前端发送的帖子信息后，进行敏感词过滤，然后存到数据库中。返回一个封装的结果集（封装成了JSON字符串String，故前端需要将其转换为JSON对象，其中包括操作是否成功的信息和返回地数据。）


在帖子详情页显示评论

1. 明确评论结构。
评论在详情页可以分为两类：
1. 对帖子的评论。
2. 对评论的评论。（回复） 而回复也分为两种
        1.  没有回复对象的回复，如点击**评论**右边的回复进行的回复。
        2.  有回复对象（targetId）的回复，如点击某条**回复**右边的回复进行的回复。
故由Service和Dao层将评论信息从数据库中获取到后。由表现层进行评论的分页展示。
每条评论包括：对帖子的评论，该评论的回复（不一定存在，且回复有两种可能。）
1.获取帖子的所有评论：根据评论对象类型（帖子），类型Id（帖子的Id），offset，limit获得该贴子下的所有评论。
2.遍历该评论集合，将每条评论的信息进行装填，如发布者信息、回复等。
       对回复的处理：
       1. 先根据评论对象类型（评论），类型Id（评论Id），offset(0),limit(max),即找到该帖子下的所有回复，不进行分页展示。
       2. 遍历获得的回复集合，对每条回复进行内容装填，如回复者信息（user）和被回复者信息(target)。
          注意，不一定有被回复者，所以需要根据targetId判断一下。reply.getTargetId() == 0 ? null : userService.findUserById(reply.getTargetId());


添加评论
首先明确前端需要传递给后端的信息：(前端传递给后端的信息都是后端靠自己是获取不到的)
1. 评论内容（content）
2. 评论对象的类型（entityType）
3. 评论对象的id（entityId）
4.（如果是回复的话）targetId
后端接收到Comment对象后，填充未初始化的字段后将其存到数据库即可（返回到详情页）。
注意：添加评论要进行**事物管理**，因为评论包含两个对数据库的操作（添加评论、更改评论的数量）。如果评论失败，不应该修改评论的数量。

展示私信会话列表
将用户的私信会话列表内容分页展示到页面中，每个会话中私信消息显示最新的一条。
（主要是sql语句较复杂）
后端接收：current（隐含在Page对象中，由SpringMVC自动注入）
后端根据userId查询到所有包含该用户的会话，填充每条会话的信息（未读消息数量、发送者信息等），分页展示到页面中

显示私信详情（即查看一个会话中的所有私信内容，并分页展示）**可优化UI**
用户点击某个会话后进入会话的详情页，展示该会话所有的私信内容。
前端给后端传递：conversationId，current
后端根据conversationId查询到该会话下的所有私信内容，然后将每条私信内容进行填充，分页展示
    更新会话未读数量
    当用户点进会话详情页时，该会话下的所有私信内容都应该设置为已读。获取到该会话下未读消息的id，然后更新状态即可。

发送私信
要显示提示信息，使用ajax，有两个位置可以发送私信
1. 在会话列表出点击发私信。
用户在前端输入：发送对象，私信内容
后端：接收到这两个字段后，填充message对象，插入到数据库，返回结果给前端。

统一处理异常
抛出异常时会查找有没有使用@ControllerAdvice注解标记了的类（该类集中处理一层的异常），如果范围符合，根据异常类型匹配到@ExceptionHandler()注解中类型匹配的异常的方法进行
异常处理。

统一记录日志（AOP）
定义一个类使用@Component（交给Spring容器管理）,@Aspect(表明该类是切面)
使用@Pointcut()标记一个方法(方法体为空)  定义切入点 (可以定义多个)
根据切入时机，使用@Before("切入点方法"),@After ,@Around.... 标记方法，在方法中加上增强的部分。

点赞和关注因为操作高频，都使用redis存储数据
点赞
使用一个likeController统一处理点赞。需要传递以下参数：
entityType        点赞对象的类型           判断点赞对象是帖子还是评论（查的key（表）不一样）
entityId          点赞对象的Id
entityUserId      点赞对象发布者的Id        用于统计收到的赞
controller调用业务层，还多传递一个参数：userId(点赞者的id)  用于存到点赞表中，统计数量等信息。
业务层先根据传递的信息生成key（表名），然后判断该用户对该内容是否已经点过赞。（判断对应内容是否包含该userId）
？ 取消点赞，1.将userId，从点赞列表中移出，  2.发布者收到的赞的数量 --
:  点赞     1.将userId，加到点赞列表中，  2.发布者收到的赞的数量 ++
业务层对redis Nosql数据库有两个操作，应该是要么全成功，要么全失败的。
所以需要对其进行**事物管理**，使用编程式事物进行管理。

在帖子详情页有三个地方可以进行点赞操作：
1.  帖子右侧。点击点赞（超链接）后，onclick调用like（）函数，发送ajax请求，到likeController，处理后返回数据（点赞状态、数量）。回调函数
            接收到返回数据后，将对应标签中的点赞状态、数量改变。
            而若是没有点击点赞的话。显示点赞状态、数量时，是根据discussPostController返回的数据进行显示的。

2.  评论右侧。同上，只是传递的entityType、entityId等参数不同，过程相同
3.  回复右侧。同上。

关注&取消关注
是关注操作还是取消关注操作是由前端根据class中的内容判断的，然后发送ajax请求时请求不同的controller方法。

前端点击关注按钮后向后端发送ajax请求，传递参数：entityType , entityId。
controller接收到请求后，先获取当前登录的用户信息。调用service完成操作，传递参数：
userId，关注者Id；entityType，entityId（被关注者信息）；
service收到参数后，生成操作的key，，**使用编程式事务管理**
将该用户的对应实体类型followee中增加一个内容：entityId
对应实体类型的粉丝中添加一个用户id：userId

无论是关注还是点赞，都是将执行操作的对象存到对应的表中。


个人主页（自己或他人）
（1）个人信息板块
由UserController中的对应请求（"/user/profile"）进行处理。
需要返回给前端的数据：
1. 对应用户的信息
2. 所有获赞信息
3. 所有关注信息（关注人数、粉丝数；点击后可以跳转到页面查看关注列表等）
4. 一个关注按钮（需要按照当前用户的关注状态动态显示）

自己或他人关注信息列表展示（关注的人&粉丝）
1. 关注的人
